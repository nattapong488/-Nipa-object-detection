// package: 
// file: NvisionRequest.proto

import * as jspb from "google-protobuf";

export class BoundingBox extends jspb.Message {
  getBottom(): number;
  setBottom(value: number): void;

  getLeft(): number;
  setLeft(value: number): void;

  getRight(): number;
  setRight(value: number): void;

  getTop(): number;
  setTop(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BoundingBox.AsObject;
  static toObject(includeInstance: boolean, msg: BoundingBox): BoundingBox.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BoundingBox, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BoundingBox;
  static deserializeBinaryFromReader(message: BoundingBox, reader: jspb.BinaryReader): BoundingBox;
}

export namespace BoundingBox {
  export type AsObject = {
    bottom: number,
    left: number,
    right: number,
    top: number,
  }
}

export class ObjectDetection extends jspb.Message {
  getCroppedImage(): Uint8Array | string;
  getCroppedImage_asU8(): Uint8Array;
  getCroppedImage_asB64(): string;
  setCroppedImage(value: Uint8Array | string): void;

  hasBoundingBox(): boolean;
  clearBoundingBox(): void;
  getBoundingBox(): BoundingBox | undefined;
  setBoundingBox(value?: BoundingBox): void;

  getName(): string;
  setName(value: string): void;

  getParent(): string;
  setParent(value: string): void;

  getConfidence(): number;
  setConfidence(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ObjectDetection.AsObject;
  static toObject(includeInstance: boolean, msg: ObjectDetection): ObjectDetection.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ObjectDetection, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ObjectDetection;
  static deserializeBinaryFromReader(message: ObjectDetection, reader: jspb.BinaryReader): ObjectDetection;
}

export namespace ObjectDetection {
  export type AsObject = {
    croppedImage: Uint8Array | string,
    boundingBox?: BoundingBox.AsObject,
    name: string,
    parent: string,
    confidence: number,
  }
}

export class NvisionRequest extends jspb.Message {
  getEncoding(): NvisionRequest.EncodeTypeMap[keyof NvisionRequest.EncodeTypeMap];
  setEncoding(value: NvisionRequest.EncodeTypeMap[keyof NvisionRequest.EncodeTypeMap]): void;

  getServiceId(): string;
  setServiceId(value: string): void;

  getSourceId(): string;
  setSourceId(value: string): void;

  getFrameId(): string;
  setFrameId(value: string): void;

  getCreatedAt(): string;
  setCreatedAt(value: string): void;

  getRawData(): Uint8Array | string;
  getRawData_asU8(): Uint8Array;
  getRawData_asB64(): string;
  setRawData(value: Uint8Array | string): void;

  clearTargetClassesList(): void;
  getTargetClassesList(): Array<string>;
  setTargetClassesList(value: Array<string>): void;
  addTargetClasses(value: string, index?: number): string;

  clearConfigurationsList(): void;
  getConfigurationsList(): Array<NvisionRequest.Configuration>;
  setConfigurationsList(value: Array<NvisionRequest.Configuration>): void;
  addConfigurations(value?: NvisionRequest.Configuration, index?: number): NvisionRequest.Configuration;

  clearDetectedObjectsList(): void;
  getDetectedObjectsList(): Array<ObjectDetection>;
  setDetectedObjectsList(value: Array<ObjectDetection>): void;
  addDetectedObjects(value?: ObjectDetection, index?: number): ObjectDetection;

  clearDetectedFacesList(): void;
  getDetectedFacesList(): Array<ObjectDetection>;
  setDetectedFacesList(value: Array<ObjectDetection>): void;
  addDetectedFaces(value?: ObjectDetection, index?: number): ObjectDetection;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): NvisionRequest.AsObject;
  static toObject(includeInstance: boolean, msg: NvisionRequest): NvisionRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: NvisionRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): NvisionRequest;
  static deserializeBinaryFromReader(message: NvisionRequest, reader: jspb.BinaryReader): NvisionRequest;
}

export namespace NvisionRequest {
  export type AsObject = {
    encoding: NvisionRequest.EncodeTypeMap[keyof NvisionRequest.EncodeTypeMap],
    serviceId: string,
    sourceId: string,
    frameId: string,
    createdAt: string,
    rawData: Uint8Array | string,
    targetClassesList: Array<string>,
    configurationsList: Array<NvisionRequest.Configuration.AsObject>,
    detectedObjectsList: Array<ObjectDetection.AsObject>,
    detectedFacesList: Array<ObjectDetection.AsObject>,
  }

  export class Configuration extends jspb.Message {
    getParameter(): string;
    setParameter(value: string): void;

    getValue(): string;
    setValue(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Configuration.AsObject;
    static toObject(includeInstance: boolean, msg: Configuration): Configuration.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: Configuration, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Configuration;
    static deserializeBinaryFromReader(message: Configuration, reader: jspb.BinaryReader): Configuration;
  }

  export namespace Configuration {
    export type AsObject = {
      parameter: string,
      value: string,
    }
  }

  export interface EncodeTypeMap {
    BUFFER: 0;
    BASE64: 1;
  }

  export const EncodeType: EncodeTypeMap;
}

